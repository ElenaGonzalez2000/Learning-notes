# â“ Preguntas frecuentes sobre POO en C# (Dudas resueltas)

Este documento complementa la guÃ­a de ProgramaciÃ³n Orientada a Objetos en C#, respondiendo dudas especÃ­ficas que suelen surgir al estudiar herencia, polimorfismo, ocultamiento y referencias a objetos.

---

## ğŸ“Œ Â¿QuÃ© pasa si uso `new` para redefinir una variable como `Vida` en la clase hija?

Cuando usÃ¡s `new`, **no estÃ¡s sobreescribiendo** el miembro de la clase padre, sino **ocultÃ¡ndolo**. Eso significa que el valor accedido **dependerÃ¡ del tipo de la referencia**, no del objeto real.

```csharp
public class Personaje
{
    public int Vida = 100;
}

public class Guerrero : Personaje
{
    public new int Vida = 150;
}

Personaje p = new Guerrero();
Console.WriteLine(p.Vida); // Muestra 100 âš ï¸

Guerrero g = new Guerrero();
Console.WriteLine(g.Vida); // Muestra 150 âœ…
```

âœ”ï¸ Si querÃ©s **polimorfismo verdadero**, usÃ¡ `virtual` + `override`, y preferentemente trabajÃ¡ con **propiedades**, no campos.

---

## ğŸ” Â¿Para quÃ© sirve el modificador `new` si no reemplaza como `override`?

Aunque `new` no genera polimorfismo, puede ser Ãºtil en estos casos:

- Cuando el miembro del padre **no es `virtual`** y no podÃ©s modificarlo (por ejemplo, viene de una librerÃ­a externa).
- Cuando querÃ©s que el miembro se comporte diferente **solo en contextos donde se usa la clase hija directamente**.
- Para dejar en claro que **estÃ¡s ocultando intencionalmente** un miembro heredado.

ğŸ”´ Pero **no es recomendable duplicar atributos con el mismo nombre** entre padre e hijo si podÃ©s evitarlo, ya que complica el mantenimiento y lectura del cÃ³digo.

---

## ğŸ§  Â¿QuÃ© cambia si referencio a la clase padre en vez de la hija?

Cuando usÃ¡s una **referencia del tipo padre**, sÃ³lo podÃ©s acceder a lo que la clase padre "conoce". Si el mÃ©todo es `virtual` y fue `override`, entonces se ejecuta la versiÃ³n mÃ¡s especÃ­fica (polimorfismo).

```csharp
Personaje p = new Mago();
p.Habilidad(); // âœ… Ejecuta el override de Mago

// Pero esto no se puede:
p.LanzarHechizo(); // âŒ Error: Personaje no tiene ese mÃ©todo
```

Para acceder a los mÃ©todos propios de `Mago`, necesitÃ¡s una referencia del tipo `Mago`, o usar *casting*:

```csharp
if (p is Mago magoReal)
{
    magoReal.LanzarHechizo();
}
```

---

## âœ… Â¿Entonces siempre es mejor referenciar a la clase hija?

No necesariamente. Depende del objetivo:

| Objetivo                                     | Tipo de referencia recomendado |
|----------------------------------------------|-------------------------------|
| Usar mÃ©todos propios del hijo                | Clase hija                    |
| Tratar todos los objetos de forma genÃ©rica   | Clase padre                   |
| Aplicar polimorfismo (`override`)            | Clase padre                   |
| Acceder a mÃ©todos override + propios del hijo| Clase padre + casting         |

ğŸ“Œ Usar referencias al padre permite escribir cÃ³digo mÃ¡s genÃ©rico y escalable, mientras que la referencia al hijo da acceso completo al objeto.

---

## ğŸ” Â¿QuÃ© diferencia hay entre `virtual`, `override`, `abstract` y `new`?

| Modificador   | Â¿DÃ³nde se usa?      | Â¿Permite polimorfismo? | Â¿Tiene implementaciÃ³n? | Â¿Obliga a sobrescribir? | Notas clave |
|---------------|----------------------|--------------------------|--------------------------|---------------------------|-------------|
| `virtual`     | Clase padre           | âœ… SÃ­                    | âœ… SÃ­                    | âŒ No                    | Permite `override` opcional en hijos |
| `override`    | Clase hija            | âœ… SÃ­                    | âœ… SÃ­                    | ğŸ” Depende del padre     | Se usa si el padre tiene `virtual` o `abstract` |
| `abstract`    | Clase padre (abstract)| âœ… SÃ­                    | âŒ No                    | âœ… SÃ­                    | El hijo debe implementar sÃ­ o sÃ­ |
| `new`         | Clase hija            | âŒ No                    | âœ… SÃ­                    | âŒ No                    | Oculta miembro, no lo reemplaza |

---

ğŸ“š Este archivo estÃ¡ pensado como una hoja de referencia rÃ¡pida. Ideal para repasar antes de una prÃ¡ctica, parcial o proyecto real con POO en C#.

